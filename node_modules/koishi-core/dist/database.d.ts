import { Observed } from 'koishi-utils';
export interface Usage {
    last?: number;
    count?: number;
}
export declare enum UserFlag {
    ignore = 1
}
export declare const userFlags: (keyof typeof UserFlag)[];
export interface UserData {
    id: number;
    flag: number;
    authority: number;
    usage: Record<string, Usage> & {
        $date?: number;
    };
}
export declare type User<K extends UserField = UserField> = Observed<Pick<UserData, K | 'id'>>;
export declare type UserField = keyof UserData;
export declare const userFields: UserField[];
declare type UserGetter = (id: number, authority: number) => Partial<UserData>;
export declare function extendUser(getter: UserGetter): void;
export declare function createUser(id: number, authority: number): UserData;
export interface GroupData {
    id: number;
    flag: number;
    assignee: number;
}
export declare enum GroupFlag {
    noCommand = 1,
    noResponse = 2,
    noEmit = 4
}
export declare const groupFlags: (keyof typeof GroupFlag)[];
export declare type Group<K extends GroupField = GroupField> = Observed<Pick<GroupData, K | 'id'>>;
export declare type GroupField = keyof GroupData;
export declare const groupFields: GroupField[];
declare type GroupGetter = (id: number, assignee: number) => Partial<GroupData>;
export declare function extendGroup(getter: GroupGetter): void;
export declare function createGroup(id: number, assignee: number): GroupData;
export interface UserMethods {
    getUser<K extends UserField>(userId: number, fields?: readonly K[]): Promise<Pick<UserData, K | 'id'>>;
    getUser<K extends UserField>(userId: number, defaultAuthority?: number, fields?: readonly K[]): Promise<Pick<UserData, K | 'id'>>;
    getUsers<K extends UserField>(fields?: K[]): Promise<Pick<UserData, K>[]>;
    getUsers<K extends UserField>(ids: readonly number[], fields?: readonly K[]): Promise<Pick<UserData, K>[]>;
    setUser(userId: number, data: Partial<UserData>): Promise<any>;
    observeUser<K extends UserField>(user: number | UserData, fields?: readonly K[]): Promise<User<K>>;
    observeUser<K extends UserField>(user: number | UserData, defaultAuthority?: number, fields?: readonly K[]): Promise<User<K>>;
    getUserCount(): Promise<number>;
}
export interface GroupMethods {
    getGroup<K extends GroupField>(groupId: number, fields?: readonly K[]): Promise<Pick<GroupData, K | 'id'>>;
    getGroup<K extends GroupField>(groupId: number, selfId?: number, fields?: readonly K[]): Promise<Pick<GroupData, K | 'id'>>;
    getAllGroups<K extends GroupField>(assignees?: readonly number[]): Promise<Pick<GroupData, K>[]>;
    getAllGroups<K extends GroupField>(fields?: readonly K[], assignees?: readonly number[]): Promise<Pick<GroupData, K>[]>;
    setGroup(groupId: number, data: Partial<GroupData>): Promise<any>;
    observeGroup<K extends GroupField>(group: number | GroupData, fields?: readonly K[]): Promise<Group<K>>;
    observeGroup<K extends GroupField>(group: number | GroupData, selfId?: number, fields?: readonly K[]): Promise<Group<K>>;
    getGroupCount(): Promise<number>;
}
export interface TableMethods {
    user: UserMethods;
    group: GroupMethods;
}
export interface TableData {
    user: UserData;
    group: GroupData;
}
export declare type TableType = keyof TableMethods;
declare type TableMap = Partial<Record<TableType, SubdatabaseType>>;
declare type UnionToIntersection<U> = (U extends any ? (key: U) => void : never) extends (key: infer I) => void ? I : never;
export declare type Database = Subdatabases & UnionToIntersection<TableMethods[TableType]>;
export interface DatabaseConfig {
    $tables?: TableMap;
}
export interface Subdatabases {
}
export interface InjectOptions {
}
declare type SubdatabaseType = keyof Subdatabases;
declare type InjectionMap<S extends SubdatabaseType> = Partial<Record<TableType, DatabaseInjections<S>>>;
export declare type TableConfig<K extends SubdatabaseType> = K extends keyof InjectOptions ? InjectOptions[K] : never;
export declare type InjectConfig<K extends SubdatabaseType> = Partial<Record<TableType, TableConfig<K>>>;
interface Subdatabase<T extends SubdatabaseType = SubdatabaseType, A extends AbstractDatabase = AbstractDatabase> {
    new (config: DatabaseConfig[T], injectConfig?: InjectConfig<T>): A;
    identify?(config: DatabaseConfig[T]): string | number;
    _methods?: InjectionMap<T>;
    _options?: InjectConfig<T>;
    _managers?: DatabaseManager[];
}
export interface AbstractDatabase {
    start?(): void | Promise<void>;
    stop?(): void | Promise<void>;
}
export declare function registerDatabase<K extends SubdatabaseType>(name: K, subdatabase: Subdatabase<K, {}>): void;
export declare type DatabaseInjections<K extends SubdatabaseType, T extends TableType = TableType> = {
    [M in keyof TableMethods[T]]?: TableMethods[T][M] extends (...args: infer P) => infer R ? (this: DatabaseInjections<K, T> & Subdatabases[K], ...args: P) => R : never;
};
export declare function injectMethods<K extends SubdatabaseType, T extends TableType>(name: K, table: T, methods: DatabaseInjections<K, T>, options?: TableConfig<K>): void;
declare class DatabaseManager {
    config: DatabaseConfig;
    database: Database;
    private explicitTables;
    private implicitTables;
    constructor(config: DatabaseConfig);
    createSubdatabase<S extends SubdatabaseType>(sub: S, config: any): AbstractDatabase;
    bindSubdatabase<S extends SubdatabaseType>(type: S, config: any): void;
    injectMethods<S extends SubdatabaseType, T extends TableType>(sub: S, table: T, methods: any): void;
}
export declare function createDatabase(config: DatabaseConfig): Database;
export {};
