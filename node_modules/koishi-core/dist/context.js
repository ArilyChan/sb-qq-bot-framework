"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const koishi_utils_1 = require("koishi-utils");
const command_1 = require("./command");
const meta_1 = require("./meta");
const events_1 = require("events");
const messages_1 = require("./messages");
const util_1 = require("util");
var ContextScope;
(function (ContextScope) {
    function stringify(scope) {
        return scope.map(([include, exclude], index) => {
            const type = meta_1.contextTypes[index];
            const sign = include ? '+' : '-';
            const idList = include || exclude;
            return `${type}${sign}${idList.join(',')}`;
        }).filter(a => a).join(';');
    }
    ContextScope.stringify = stringify;
    function parse(identifier) {
        const scope = noopScope.slice();
        identifier.split(';').forEach((segment) => {
            const capture = /^(user|group|discuss)(?:([+-])(\d+(?:,\d+)*))?$/.exec(segment);
            if (!capture)
                throw new Error(messages_1.errors.INVALID_IDENTIFIER);
            const [_, type, sign = '-', list] = capture;
            const idList = list ? list.split(',').map(n => +n) : [];
            scope[meta_1.contextTypes[type]] = sign === '+' ? [idList, null] : [null, idList];
        });
        return scope;
    }
    ContextScope.parse = parse;
})(ContextScope = exports.ContextScope || (exports.ContextScope = {}));
const noopScope = [[[], null], [[], null], [[], null]];
const noopIdentifier = ContextScope.stringify(noopScope);
exports.logTypes = ['warn', 'info', 'debug', 'success', 'error'];
class Context {
    constructor(identifier, _scope) {
        this.identifier = identifier;
        this._scope = _scope;
        this.receiver = new events_1.EventEmitter();
        this.receiver.on('error', (error) => {
            this.logger('koishi').warn(error);
        });
        this.logger = (scope = '') => {
            const logger = {};
            for (const type of exports.logTypes) {
                logger[type] = (...args) => {
                    this.app.receiver.emit('logger', scope, util_1.format(...args), type);
                    this.app.receiver.emit(`logger/${type}`, scope, util_1.format(...args));
                };
            }
            return logger;
        };
    }
    inverse() {
        return this.app.createContext(this._scope.map(([include, exclude]) => {
            return include ? [null, include.slice()] : [exclude.slice(), []];
        }));
    }
    plus(ctx) {
        return this.app.createContext(this._scope.map(([include1, exclude1], index) => {
            const [include2, exclude2] = ctx._scope[index];
            return include1
                ? include2 ? [koishi_utils_1.union(include1, include2), null] : [null, koishi_utils_1.difference(exclude2, include1)]
                : [null, include2 ? koishi_utils_1.difference(exclude1, include2) : koishi_utils_1.intersection(exclude1, exclude2)];
        }));
    }
    minus(ctx) {
        return this.app.createContext(this._scope.map(([include1, exclude1], index) => {
            const [include2, exclude2] = ctx._scope[index];
            return include1
                ? [include2 ? koishi_utils_1.difference(include1, include2) : koishi_utils_1.intersection(include1, exclude2), null]
                : include2 ? [null, koishi_utils_1.union(include2, exclude1)] : [koishi_utils_1.difference(exclude2, exclude1), null];
        }));
    }
    intersect(ctx) {
        return this.app.createContext(this._scope.map(([include1, exclude1], index) => {
            const [include2, exclude2] = ctx._scope[index];
            return include1
                ? [include2 ? koishi_utils_1.intersection(include1, include2) : koishi_utils_1.difference(include1, exclude2), null]
                : include2 ? [koishi_utils_1.difference(include2, exclude1), null] : [null, koishi_utils_1.union(exclude1, exclude2)];
        }));
    }
    match(meta) {
        const [include, exclude] = this._scope[meta_1.contextTypes[meta.$ctxType]];
        return include ? include.includes(meta.$ctxId) : !exclude.includes(meta.$ctxId);
    }
    contain(ctx) {
        return this._scope.every(([include1, exclude1], index) => {
            const [include2, exclude2] = ctx._scope[index];
            return include1
                ? include2 && koishi_utils_1.contain(include1, include2)
                : include2 ? !koishi_utils_1.intersection(include2, exclude1).length : koishi_utils_1.contain(exclude2, exclude1);
        });
    }
    plugin(plugin, options) {
        if (options === false)
            return;
        const ctx = Object.create(this);
        if (typeof plugin === 'function') {
            plugin(ctx, options);
        }
        else if (plugin && typeof plugin === 'object' && typeof plugin.apply === 'function') {
            plugin.apply(ctx, options);
        }
        else {
            throw new Error(messages_1.errors.INVALID_PLUGIN);
        }
        return this;
    }
    middleware(middleware) {
        const { maxMiddlewares } = this.app.options;
        if (this.app._middlewares.length >= maxMiddlewares) {
            this.logger('koishi').warn(new Error(util_1.format(messages_1.errors.MAX_MIDDLEWARES, maxMiddlewares)));
        }
        else {
            this.app._middlewares.push([this, middleware]);
        }
        return this;
    }
    addMiddleware(middleware) {
        return this.middleware(middleware);
    }
    prependMiddleware(middleware) {
        const { maxMiddlewares } = this.app.options;
        if (this.app._middlewares.length >= maxMiddlewares) {
            this.logger('koishi').warn(new Error(util_1.format(messages_1.errors.MAX_MIDDLEWARES, maxMiddlewares)));
        }
        else {
            this.app._middlewares.unshift([this, middleware]);
        }
        return this;
    }
    removeMiddleware(middleware) {
        const index = this.app._middlewares.findIndex(([c, m]) => c === this && m === middleware);
        if (index >= 0) {
            this.app._middlewares.splice(index, 1);
            return true;
        }
    }
    onceMiddleware(middleware, meta) {
        const identifier = meta ? meta.$ctxId + meta.$ctxType + meta.userId : undefined;
        const listener = async (meta, next) => {
            if (identifier && meta.$ctxId + meta.$ctxType + meta.userId !== identifier)
                return next();
            this.removeMiddleware(listener);
            return middleware(meta, next);
        };
        return this.prependMiddleware(listener);
    }
    command(rawName, ...args) {
        const description = typeof args[0] === 'string' ? args.shift() : undefined;
        const config = args[0] || {};
        if (description !== undefined)
            config.description = description;
        const [path] = rawName.split(' ', 1);
        const declaration = rawName.slice(path.length);
        const segments = path.toLowerCase().split(/(?=[\\./])/);
        let parent = null;
        segments.forEach((segment) => {
            const code = segment.charCodeAt(0);
            const name = code === 46 ? parent.name + segment : code === 47 ? segment.slice(1) : segment;
            let command = this.app._commandMap[name];
            if (command) {
                if (parent) {
                    if (command === parent) {
                        throw new Error(messages_1.errors.INVALID_SUBCOMMAND);
                    }
                    if (command.parent) {
                        if (command.parent !== parent) {
                            throw new Error(messages_1.errors.INVALID_SUBCOMMAND);
                        }
                    }
                    else if (parent.context.contain(command.context)) {
                        command.parent = parent;
                        parent.children.push(command);
                    }
                    else {
                        throw new Error(messages_1.errors.INVALID_CONTEXT);
                    }
                }
                return parent = command;
            }
            const context = parent ? this.intersect(parent.context) : this;
            if (context.identifier === noopIdentifier) {
                throw new Error(messages_1.errors.INVALID_CONTEXT);
            }
            command = new command_1.Command(name, declaration, context);
            if (parent) {
                command.parent = parent;
                parent.children.push(command);
            }
            parent = command;
        });
        Object.assign(parent.config, config);
        if (config.noHelpOption)
            parent.removeOption('help');
        return parent;
    }
    _getCommandByRawName(name) {
        const index = name.lastIndexOf('/');
        return this.app._commandMap[name.slice(index + 1).toLowerCase()];
    }
    getCommand(name, meta) {
        const command = this._getCommandByRawName(name);
        if ((command === null || command === void 0 ? void 0 : command.context.match(meta)) && !command.getConfig('disable', meta)) {
            return command;
        }
    }
    runCommand(name, meta, args = [], options = {}, rest = '') {
        const command = this._getCommandByRawName(name);
        if (!command || !command.context.match(meta) || command.getConfig('disable', meta)) {
            return meta.$send(messages_1.messages.COMMAND_NOT_FOUND);
        }
        const unknown = Object.keys(options).filter(key => !command._optsDef[key]);
        return command.execute({ meta, command, args, options, rest, unknown });
    }
    end() {
        return this.app;
    }
}
exports.Context = Context;
