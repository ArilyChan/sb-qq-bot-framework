"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = require("./messages");
const koishi_utils_1 = require("koishi-utils");
const util_1 = require("util");
const utils_1 = require("./utils");
const parser_1 = require("./parser");
const defaultConfig = {
    authority: 1,
    maxUsage: Infinity,
    minInterval: 0,
    showWarning: true,
};
var CommandHint;
(function (CommandHint) {
    CommandHint[CommandHint["USAGE_EXHAUSTED"] = 1] = "USAGE_EXHAUSTED";
    CommandHint[CommandHint["TOO_FREQUENT"] = 2] = "TOO_FREQUENT";
    CommandHint[CommandHint["LOW_AUTHORITY"] = 4] = "LOW_AUTHORITY";
    CommandHint[CommandHint["INSUFFICIENT_ARGUMENTS"] = 8] = "INSUFFICIENT_ARGUMENTS";
    CommandHint[CommandHint["REDUNANT_ARGUMENTS"] = 16] = "REDUNANT_ARGUMENTS";
    CommandHint[CommandHint["UNKNOWN_OPTIONS"] = 32] = "UNKNOWN_OPTIONS";
    CommandHint[CommandHint["REQUIRED_OPTIONS"] = 64] = "REQUIRED_OPTIONS";
})(CommandHint = exports.CommandHint || (exports.CommandHint = {}));
class Command {
    constructor(name, declaration, context, config = {}) {
        this.name = name;
        this.declaration = declaration;
        this.context = context;
        this.children = [];
        this.parent = null;
        this._aliases = [];
        this._options = [];
        this._examples = [];
        this._shortcuts = {};
        this._userFields = new Set();
        this._groupFields = new Set();
        this._optsDef = {};
        if (!name)
            throw new Error(messages_1.errors.EXPECT_COMMAND_NAME);
        this._argsDef = parser_1.parseArguments(declaration);
        this.config = { ...defaultConfig, ...config };
        this._registerAlias(this.name);
        context.app._commands.push(this);
        this.option('-h, --help', messages_1.messages.SHOW_THIS_MESSAGE, { hidden: true });
    }
    static attachUserFields(userFields, { command, options = {} }) {
        if (!command)
            return;
        for (const field of command._userFields) {
            userFields.add(field);
        }
        const { maxUsage, minInterval, authority } = command.config;
        let shouldFetchAuthority = !userFields.has('authority') && authority > 0;
        let shouldFetchUsage = !(userFields.has('usage') || !maxUsage && !minInterval);
        for (const option of command._options) {
            if (option.camels[0] in options) {
                if (option.authority > 0)
                    shouldFetchAuthority = true;
                if (option.notUsage)
                    shouldFetchUsage = false;
            }
        }
        if (shouldFetchAuthority)
            userFields.add('authority');
        if (shouldFetchUsage)
            userFields.add('usage');
    }
    static attachGroupFields(groupFields, { command }) {
        if (!command)
            return;
        for (const field of command._groupFields) {
            groupFields.add(field);
        }
    }
    get app() {
        return this.context.app;
    }
    get usageName() {
        return this.config.usageName || this.name;
    }
    _registerAlias(name) {
        name = name.toLowerCase();
        this._aliases.push(name);
        const previous = this.app._commandMap[name];
        if (!previous) {
            this.app._commandMap[name] = this;
        }
        else if (previous !== this) {
            throw new Error(messages_1.errors.DUPLICATE_COMMAND);
        }
    }
    userFields(fields) {
        for (const field of fields) {
            this._userFields.add(field);
        }
        return this;
    }
    groupFields(fields) {
        for (const field of fields) {
            this._groupFields.add(field);
        }
        return this;
    }
    alias(...names) {
        for (const name of names) {
            this._registerAlias(name);
        }
        return this;
    }
    subcommand(rawName, ...args) {
        rawName = this.name + (rawName.charCodeAt(0) === 46 ? '' : '/') + rawName;
        return this.context.command(rawName, ...args);
    }
    shortcut(name, config = {}) {
        config = this._shortcuts[name] = {
            name,
            command: this,
            authority: this.config.authority,
            ...config,
        };
        this.app._shortcutMap[name] = this;
        this.app._shortcuts.push(config);
        return this;
    }
    usage(text) {
        this._usage = text;
        return this;
    }
    example(example) {
        this._examples.push(example);
        return this;
    }
    option(rawName, ...args) {
        const description = typeof args[0] === 'string' ? args.shift() : undefined;
        const config = args[0] || {};
        const option = parser_1.parseOption(rawName, description, config, this._optsDef);
        this._options.push(option);
        for (const name of option.names) {
            if (name in this._optsDef) {
                throw new Error(messages_1.errors.DUPLICATE_OPTION);
            }
            this._optsDef[name] = option;
        }
        return this;
    }
    removeOption(name) {
        name = name.replace(/^-+/, '');
        const option = this._optsDef[name];
        if (!option)
            return false;
        for (const name of option.names) {
            delete this._optsDef[name];
        }
        const index = this._options.indexOf(option);
        this._options.splice(index, 1);
        return true;
    }
    action(callback) {
        this._action = callback;
        return this;
    }
    getConfig(key, meta) {
        const value = this.config[key];
        return typeof value === 'function' ? value(meta.$user) : value;
    }
    parse(source) {
        return parser_1.parseLine(source, this._argsDef, this._optsDef);
    }
    async execute(argv, next = koishi_utils_1.noop) {
        const options = argv.options || (argv.options = {});
        const unknown = argv.unknown || (argv.unknown = []);
        const args = argv.args || (argv.args = []);
        this.app.emitEvent(argv.meta, 'before-command', argv);
        // show help when use `-h, --help` or when there is no action
        if (!this._action || options.help && !this.config.noHelpOption) {
            return this.context.runCommand('help', argv.meta, [this.name]);
        }
        // check argument count
        if (this.config.checkArgCount) {
            const nextArg = this._argsDef[args.length];
            if (nextArg === null || nextArg === void 0 ? void 0 : nextArg.required) {
                return this._sendHint(CommandHint.INSUFFICIENT_ARGUMENTS, argv.meta);
            }
            const finalArg = this._argsDef[this._argsDef.length - 1];
            if (args.length > this._argsDef.length && !finalArg.noSegment && !finalArg.variadic) {
                return this._sendHint(CommandHint.REDUNANT_ARGUMENTS, argv.meta);
            }
        }
        // check unknown options
        if (this.config.checkUnknown && unknown.length) {
            return this._sendHint(CommandHint.UNKNOWN_OPTIONS, argv.meta, unknown.join(', '));
        }
        // check required options
        if (this.config.checkRequired) {
            const absent = this._options.find((option) => {
                return option.required && !(option.longest in options);
            });
            if (absent) {
                return this._sendHint(CommandHint.REQUIRED_OPTIONS, argv.meta, absent.rawName);
            }
        }
        // check authority and usage
        const code = this._checkUser(argv.meta, options);
        if (code)
            return this._sendHint(code, argv.meta);
        // execute command
        this.context.logger('koishi:command').debug('execute %s', this.name);
        this.app.emitEvent(argv.meta, 'command', argv);
        let skipped = false;
        argv.next = (_next) => {
            skipped = true;
            return next(_next);
        };
        try {
            await this._action(argv, ...args);
            if (!skipped)
                this.app.emitEvent(argv.meta, 'after-command', argv);
        }
        catch (error) {
            this.app.receiver.emit('error/command', error);
            this.app.receiver.emit('error', error);
        }
    }
    _sendHint(code, meta, ...param) {
        let { showWarning } = this.config;
        if (typeof showWarning === 'boolean') {
            showWarning = -showWarning;
        }
        if (showWarning & code) {
            return meta.$send(util_1.format(messages_1.messages[CommandHint[code]], ...param));
        }
    }
    /** check authority and usage */
    _checkUser(meta, options) {
        const user = meta.$user;
        if (!user)
            return;
        let isUsage = true;
        // check authority
        if (this.config.authority > user.authority) {
            return CommandHint.LOW_AUTHORITY;
        }
        for (const option of this._options) {
            if (option.camels[0] in options) {
                if (option.authority > user.authority) {
                    return CommandHint.LOW_AUTHORITY;
                }
                if (option.notUsage)
                    isUsage = false;
            }
        }
        // check usage
        if (isUsage) {
            const minInterval = this.getConfig('minInterval', meta);
            const maxUsage = this.getConfig('maxUsage', meta);
            if (maxUsage < Infinity || minInterval > 0) {
                return utils_1.updateUsage(this.usageName, user, { maxUsage, minInterval });
            }
        }
    }
    end() {
        return this.context;
    }
}
exports.Command = Command;
