"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UserFlag;
(function (UserFlag) {
    UserFlag[UserFlag["ignore"] = 1] = "ignore";
})(UserFlag = exports.UserFlag || (exports.UserFlag = {}));
exports.userFlags = ['ignore'];
exports.userFields = [];
const userGetters = [];
function extendUser(getter) {
    userGetters.push(getter);
    exports.userFields.push(...Object.keys(getter(0, 0)));
}
exports.extendUser = extendUser;
extendUser((id, authority) => ({
    id,
    authority,
    flag: 0,
    usage: {},
}));
function createUser(id, authority) {
    const result = {};
    for (const getter of userGetters) {
        Object.assign(result, getter(id, authority));
    }
    return result;
}
exports.createUser = createUser;
var GroupFlag;
(function (GroupFlag) {
    GroupFlag[GroupFlag["noCommand"] = 1] = "noCommand";
    GroupFlag[GroupFlag["noResponse"] = 2] = "noResponse";
    GroupFlag[GroupFlag["noEmit"] = 4] = "noEmit";
})(GroupFlag = exports.GroupFlag || (exports.GroupFlag = {}));
exports.groupFlags = ['noCommand', 'noResponse', 'noEmit'];
exports.groupFields = [];
const groupGetters = [];
function extendGroup(getter) {
    groupGetters.push(getter);
    exports.groupFields.push(...Object.keys(getter(0, 0)));
}
exports.extendGroup = extendGroup;
extendGroup((id, assignee) => ({
    id,
    assignee,
    flag: assignee ? 0 : 3,
}));
function createGroup(id, assignee) {
    const result = {};
    for (const getter of groupGetters) {
        Object.assign(result, getter(id, assignee));
    }
    return result;
}
exports.createGroup = createGroup;
const unknownMethods = {};
const unknownOptions = {};
const subdatabases = {};
const existingDatabases = {};
function registerDatabase(name, subdatabase) {
    var _a, _b;
    subdatabases[name] = subdatabase;
    subdatabase._methods = (_a = unknownMethods[name]) !== null && _a !== void 0 ? _a : {};
    subdatabase._options = (_b = unknownOptions[name]) !== null && _b !== void 0 ? _b : {};
    subdatabase._managers = [];
}
exports.registerDatabase = registerDatabase;
function injectMethods(name, table, methods, options) {
    const Subdatabase = subdatabases[name];
    let methodMap;
    let optionMap;
    // inject before subdatabase was registered
    if (!Subdatabase) {
        methodMap = unknownMethods[name] || (unknownMethods[name] = {});
        optionMap = unknownOptions[name] || (unknownOptions[name] = {});
    }
    else {
        optionMap = Subdatabase._options;
        methodMap = Subdatabase._methods;
        Subdatabase._managers.forEach(manager => manager.injectMethods(name, table, methods));
    }
    methodMap[table] = { ...methodMap[table], ...methods };
    optionMap[table] = { ...optionMap[table], ...options };
}
exports.injectMethods = injectMethods;
class DatabaseManager {
    constructor(config) {
        this.config = config;
        this.database = {};
        this.implicitTables = {};
        this.explicitTables = config.$tables || {};
        for (const table in this.explicitTables) {
            const name = this.explicitTables[table];
            if (!config[name])
                throw new Error(`database "${name}" not configurated`);
        }
        for (const type in subdatabases) {
            this.bindSubdatabase(type, config[type]);
        }
    }
    createSubdatabase(sub, config) {
        var _a, _b;
        const Subdatabase = subdatabases[sub];
        const identifier = (_a = config.identifier) !== null && _a !== void 0 ? _a : (config.identifier = (_b = Subdatabase.identify) === null || _b === void 0 ? void 0 : _b.call(Subdatabase, config));
        const databases = existingDatabases[sub] || (existingDatabases[sub] = {});
        return identifier in databases
            ? databases[identifier]
            : databases[identifier] = new Subdatabase({ identifier, ...config }, Subdatabase._options);
    }
    bindSubdatabase(type, config) {
        if (!config)
            return;
        const Subdatabase = subdatabases[type];
        const subdatabase = this.createSubdatabase(type, config);
        this.database[type] = subdatabase;
        Subdatabase._managers.push(this);
        for (const table in Subdatabase._methods) {
            this.injectMethods(type, table, Subdatabase._methods[table]);
        }
    }
    injectMethods(sub, table, methods) {
        const subdatabase = this.database[sub];
        if (!this.explicitTables[table] && this.implicitTables[table] && this.implicitTables[table] !== sub) {
            throw new Error(`database "${this.implicitTables[table]}" and "${sub}" conflict on table "${table}"`);
        }
        else if (!this.explicitTables[table] || this.explicitTables[table] === sub) {
            this.implicitTables[table] = sub;
            for (const name in methods) {
                subdatabase[name] = this.database[name] = methods[name].bind(subdatabase);
            }
        }
    }
}
function createDatabase(config) {
    return new DatabaseManager(config).database;
}
exports.createDatabase = createDatabase;
