/// <reference types="node" />
import { Command, CommandConfig, ParsedCommandLine } from './command';
import { Meta } from './meta';
import { EventEmitter } from 'events';
import { Sender } from './sender';
import { App } from './app';
import { Database, UserField, GroupField } from './database';
export declare type NextFunction = (next?: NextFunction) => any;
export declare type Middleware = (meta: Meta<'message'>, next: NextFunction) => any;
declare type PluginFunction<T extends Context, U = any> = (ctx: T, options: U) => void;
declare type PluginObject<T extends Context, U = any> = {
    name?: string;
    apply: PluginFunction<T, U>;
};
export declare type Plugin<T extends Context = Context, U = any> = PluginFunction<T, U> | PluginObject<T, U>;
declare type Subscope = [number[], number[]];
export declare type ContextScope = Subscope[];
export declare namespace ContextScope {
    function stringify(scope: ContextScope): string;
    function parse(identifier: string): Subscope[];
}
export interface Logger {
    warn(format: any, ...param: any): void;
    info(format: any, ...param: any): void;
    debug(format: any, ...param: any): void;
    success(format: any, ...param: any): void;
    error(format: any, ...param: any): void;
}
export declare const logTypes: (keyof Logger)[];
export declare type LogEvents = 'logger/warn' | 'logger/info' | 'logger/debug' | 'logger/success' | 'logger/error';
export declare class Context {
    readonly identifier: string;
    private readonly _scope;
    app: App;
    sender: Sender;
    database: Database;
    logger: (scope?: string) => Logger;
    receiver: Receiver;
    constructor(identifier: string, _scope: ContextScope);
    inverse(): Context;
    plus(ctx: Context): Context;
    minus(ctx: Context): Context;
    intersect(ctx: Context): Context;
    match(meta: Meta): boolean;
    contain(ctx: Context): boolean;
    plugin<T extends PluginFunction<this>>(plugin: T, options?: T extends PluginFunction<this, infer U> ? U : never): this;
    plugin<T extends PluginObject<this>>(plugin: T, options?: T extends PluginObject<this, infer U> ? U : never): this;
    middleware(middleware: Middleware): this;
    addMiddleware(middleware: Middleware): this;
    prependMiddleware(middleware: Middleware): this;
    removeMiddleware(middleware: Middleware): boolean;
    onceMiddleware(middleware: Middleware, meta?: Meta): this;
    command(rawName: string, config?: CommandConfig): Command;
    command(rawName: string, description: string, config?: CommandConfig): Command;
    protected _getCommandByRawName(name: string): Command;
    getCommand(name: string, meta: Meta<'message'>): Command;
    runCommand(name: string, meta: Meta<'message'>, args?: string[], options?: Record<string, any>, rest?: string): any;
    end(): App;
}
export interface EventMap {
    'message'(meta: Meta<'message'>): any;
    'message/normal'(meta: Meta<'message'>): any;
    'message/notice'(meta: Meta<'message'>): any;
    'message/anonymous'(meta: Meta<'message'>): any;
    'message/friend'(meta: Meta<'message'>): any;
    'message/group'(meta: Meta<'message'>): any;
    'message/discuss'(meta: Meta<'message'>): any;
    'message/other'(meta: Meta<'message'>): any;
    'friend-add'(meta: Meta<'notice'>): any;
    'group-increase'(meta: Meta<'notice'>): any;
    'group-increase/invite'(meta: Meta<'notice'>): any;
    'group-increase/approve'(meta: Meta<'notice'>): any;
    'group-decrease'(meta: Meta<'notice'>): any;
    'group-decrease/leave'(meta: Meta<'notice'>): any;
    'group-decrease/kick'(meta: Meta<'notice'>): any;
    'group-decrease/kick-me'(meta: Meta<'notice'>): any;
    'group-upload'(meta: Meta<'notice'>): any;
    'group-admin'(meta: Meta<'notice'>): any;
    'group-admin/set'(meta: Meta<'notice'>): any;
    'group-admin/unset'(meta: Meta<'notice'>): any;
    'group-ban'(meta: Meta<'notice'>): any;
    'group-ban/ban'(meta: Meta<'notice'>): any;
    'group-ban/lift-ban'(meta: Meta<'notice'>): any;
    'request/friend'(meta: Meta<'request'>): any;
    'request/group/add'(meta: Meta<'request'>): any;
    'request/group/invite'(meta: Meta<'request'>): any;
    'heartbeat'(meta: Meta<'meta_event'>): any;
    'lifecycle'(meta: Meta<'meta_event'>): any;
    'lifecycle/enable'(meta: Meta<'meta_event'>): any;
    'lifecycle/disable'(meta: Meta<'meta_event'>): any;
    'lifecycle/connect'(meta: Meta<'meta_event'>): any;
    'before-user'(fields: Set<UserField>, argv: ParsedCommandLine): any;
    'before-group'(fields: Set<GroupField>, argv: ParsedCommandLine): any;
    'attach-user'(meta: Meta<'message'>): any;
    'attach-group'(meta: Meta<'message'>): any;
    'send'(meta: Meta<'send'>): any;
    'before-send'(meta: Meta<'send'>): any;
    'before-command'(argv: ParsedCommandLine): any;
    'command'(argv: ParsedCommandLine): any;
    'after-command'(argv: ParsedCommandLine): any;
    'after-middleware'(meta: Meta<'message'>): any;
    'error'(error: Error): any;
    'error/command'(error: Error): any;
    'error/middleware'(error: Error): any;
    'logger'(scope: string, message: string, type: keyof Logger): any;
    'logger/debug'(scope: string, message: string): any;
    'logger/info'(scope: string, message: string): any;
    'logger/error'(scope: string, message: string): any;
    'logger/warn'(scope: string, message: string): any;
    'logger/success'(scope: string, message: string): any;
    'ready'(): any;
    'before-connect'(): any;
    'connect'(): any;
    'before-disconnect'(): any;
    'disconnect'(): any;
    'attach'(meta: Meta<'message'>): any;
}
export declare type Events = keyof EventMap;
export interface Receiver extends EventEmitter {
    on<K extends Events>(event: K, listener: EventMap[K]): this;
    once<K extends Events>(event: K, listener: EventMap[K]): this;
    off<K extends Events>(event: K, listener: EventMap[K]): this;
    addListener<K extends Events>(event: K, listener: EventMap[K]): this;
    removeListener<K extends Events>(event: K, listener: EventMap[K]): this;
    emit<K extends Events>(event: K, ...args: Parameters<EventMap[K]>): boolean;
}
export {};
