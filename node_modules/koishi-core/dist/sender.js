"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const koishi_utils_1 = require("koishi-utils");
class SenderError extends Error {
    constructor(args, url, retcode, selfId) {
        super(`Error when trying to send to ${url}, args: ${JSON.stringify(args)}, retcode: ${retcode}`);
        Object.defineProperties(this, {
            name: { value: 'SenderError' },
            selfId: { value: selfId },
            code: { value: retcode },
            args: { value: args },
            url: { value: url },
        });
    }
}
exports.SenderError = SenderError;
class Sender {
    constructor(app) {
        this.app = app;
        const { type } = app.options;
        if (type === 'http') {
            this._get = async (action, params) => {
                const headers = {};
                if (app.options.token) {
                    headers.Authorization = `Token ${app.options.token}`;
                }
                const uri = new URL(action, app.options.server).href;
                const { data } = await axios_1.default.get(uri, { params, headers });
                return data;
            };
        }
        else if (type === 'ws') {
            this._get = (action, params) => {
                const server = app.server;
                return server.send({ action, params });
            };
        }
    }
    async get(action, params = {}, silent = false) {
        this.app.logger('koishi:sender').debug('request %s %o', action, params);
        const response = await this._get(action, koishi_utils_1.snakeCase(params));
        this.app.logger('koishi:sender').debug('response %o', response);
        const { data, retcode } = response;
        if (retcode === 0 && !silent) {
            return koishi_utils_1.camelCase(data);
        }
        else if (retcode < 0 && !silent) {
            throw new SenderError(params, action, retcode, this.app.selfId);
        }
        else if (retcode > 1) {
            throw new SenderError(params, action, retcode, this.app.selfId);
        }
    }
    async getAsync(action, params = {}) {
        if (this.app.server.versionLessThan(4)) {
            await this.get(action, params, true);
        }
        else {
            await this.get(action + '_async', params);
        }
    }
    _assertInteger(name, value) {
        if (value === undefined)
            throw new Error('missing argument: ' + name);
        if (!koishi_utils_1.isInteger(value))
            throw new Error('invalid argument: ' + name);
    }
    _assertElement(name, value, array) {
        if (value === undefined)
            throw new Error('missing argument: ' + name);
        if (!array.includes(value))
            throw new Error('invalid argument: ' + name);
    }
    _assertVersion(label, major, minor, patch = 0) {
        if (this.app.server.versionLessThan(major, minor, patch)) {
            throw new Error(`${label} requires CQHTTP version >= ${major}.${minor}.${patch}`);
        }
    }
    _createSendMeta(sendType, $ctxType, $ctxId, message) {
        return {
            $ctxId,
            $ctxType,
            message,
            sendType,
            postType: 'send',
            userId: this.app.selfId,
            [$ctxType + 'Id']: $ctxId,
            time: Math.round(Date.now() / 1000),
        };
    }
    async sendMsg(type, ctxId, message, autoEscape = false) {
        this._assertElement('type', type, ['private', 'group', 'discuss']);
        const ctxType = type === 'private' ? 'user' : type;
        const ctxIdKey = ctxType + 'Id';
        this._assertInteger(ctxIdKey, ctxId);
        if (!message)
            return;
        const meta = this._createSendMeta(type, ctxType, ctxId, message);
        this.app.emitEvent(meta, 'before-send', meta);
        const { messageId } = await this.get('send_msg', { [ctxIdKey]: ctxId, message, autoEscape });
        meta.messageId = messageId;
        this.app.emitEvent(meta, 'send', meta);
        return messageId;
    }
    async sendMsgAsync(type, ctxId, message, autoEscape = false) {
        this._assertElement('type', type, ['private', 'group', 'discuss']);
        const ctxType = type === 'private' ? 'user' : type;
        const ctxIdKey = ctxType + 'Id';
        this._assertInteger(ctxIdKey, ctxId);
        if (!message)
            return;
        const meta = this._createSendMeta(type, ctxType, ctxId, message);
        this.app.emitEvent(meta, 'before-send', meta);
        await this.get('send_msg_async', { [ctxIdKey]: ctxId, message, autoEscape });
    }
    async sendGroupMsg(groupId, message, autoEscape = false) {
        this._assertInteger('groupId', groupId);
        if (!message)
            return;
        const meta = this._createSendMeta('group', 'group', groupId, message);
        this.app.emitEvent(meta, 'before-send', meta);
        const { messageId } = await this.get('send_group_msg', { groupId, message, autoEscape });
        meta.messageId = messageId;
        this.app.emitEvent(meta, 'send', meta);
        return messageId;
    }
    async sendGroupMsgAsync(groupId, message, autoEscape = false) {
        this._assertInteger('groupId', groupId);
        if (!message)
            return;
        const meta = this._createSendMeta('group', 'group', groupId, message);
        this.app.emitEvent(meta, 'before-send', meta);
        await this.get('send_group_msg_async', { groupId, message, autoEscape });
    }
    async sendDiscussMsg(discussId, message, autoEscape = false) {
        this._assertInteger('discussId', discussId);
        if (!message)
            return;
        const meta = this._createSendMeta('discuss', 'discuss', discussId, message);
        this.app.emitEvent(meta, 'before-send', meta);
        const { messageId } = await this.get('send_discuss_msg', { discussId, message, autoEscape });
        meta.messageId = messageId;
        this.app.emitEvent(meta, 'send', meta);
        return messageId;
    }
    async sendDiscussMsgAsync(discussId, message, autoEscape = false) {
        this._assertInteger('discussId', discussId);
        if (!message)
            return;
        const meta = this._createSendMeta('discuss', 'discuss', discussId, message);
        this.app.emitEvent(meta, 'before-send', meta);
        await this.get('send_discuss_msg_async', { discussId, message, autoEscape });
    }
    async sendPrivateMsg(userId, message, autoEscape = false) {
        this._assertInteger('userId', userId);
        if (!message)
            return;
        const meta = this._createSendMeta('private', 'user', userId, message);
        this.app.emitEvent(meta, 'before-send', meta);
        const { messageId } = await this.get('send_private_msg', { userId, message, autoEscape });
        meta.messageId = messageId;
        this.app.emitEvent(meta, 'send', meta);
        return messageId;
    }
    async sendPrivateMsgAsync(userId, message, autoEscape = false) {
        this._assertInteger('userId', userId);
        if (!message)
            return;
        const meta = this._createSendMeta('private', 'user', userId, message);
        this.app.emitEvent(meta, 'before-send', meta);
        await this.get('send_private_msg_async', { userId, message, autoEscape });
    }
    async deleteMsg(messageId) {
        this._assertInteger('messageId', messageId);
        this._assertVersion('sender.deleteMsg()', 3, 3);
        await this.get('delete_msg', { messageId });
    }
    async deleteMsgAsync(messageId) {
        this._assertInteger('messageId', messageId);
        this._assertVersion('sender.deleteMsgAsync()', 3, 3);
        return this.getAsync('delete_msg', { messageId });
    }
    async sendLike(userId, times = 1) {
        this._assertInteger('userId', userId);
        this._assertInteger('times', times);
        await this.get('send_like', { userId, times });
    }
    async sendLikeAsync(userId, times = 1) {
        this._assertInteger('userId', userId);
        this._assertInteger('times', times);
        return this.getAsync('send_like', { userId, times });
    }
    async setGroupKick(groupId, userId, rejectAddRequest) {
        this._assertInteger('groupId', groupId);
        this._assertInteger('userId', userId);
        await this.get('set_group_kick', { groupId, userId, rejectAddRequest });
    }
    async setGroupKickAsync(groupId, userId, rejectAddRequest) {
        this._assertInteger('groupId', groupId);
        this._assertInteger('userId', userId);
        return this.getAsync('set_group_kick', { groupId, userId, rejectAddRequest });
    }
    async setGroupBan(groupId, userId, duration) {
        this._assertInteger('groupId', groupId);
        this._assertInteger('userId', userId);
        await this.get('set_group_ban', { groupId, userId, duration });
    }
    async setGroupBanAsync(groupId, userId, duration) {
        this._assertInteger('groupId', groupId);
        this._assertInteger('userId', userId);
        return this.getAsync('set_group_ban', { groupId, userId, duration });
    }
    async setGroupAnonymousBan(groupId, meta, duration) {
        this._assertInteger('groupId', groupId);
        if (!meta)
            throw new Error('missing argument: anonymous or flag');
        const args = { groupId, duration };
        args[typeof meta === 'string' ? 'flag' : 'anonymous'] = meta;
        await this.get('set_group_anonymous_ban', args);
    }
    async setGroupAnonymousBanAsync(groupId, meta, duration) {
        this._assertInteger('groupId', groupId);
        if (!meta)
            throw new Error('missing argument: anonymous or flag');
        const args = { groupId, duration };
        args[typeof meta === 'string' ? 'flag' : 'anonymous'] = meta;
        return this.getAsync('set_group_anonymous_ban', args);
    }
    async setGroupWholeBan(groupId, enable = true) {
        this._assertInteger('groupId', groupId);
        await this.get('set_group_whole_ban', { groupId, enable });
    }
    async setGroupWholeBanAsync(groupId, enable = true) {
        this._assertInteger('groupId', groupId);
        return this.getAsync('set_group_whole_ban', { groupId, enable });
    }
    async setGroupAdmin(groupId, userId, enable = true) {
        this._assertInteger('groupId', groupId);
        this._assertInteger('userId', userId);
        await this.get('set_group_admin', { groupId, userId, enable });
    }
    async setGroupAdminAsync(groupId, userId, enable = true) {
        this._assertInteger('groupId', groupId);
        this._assertInteger('userId', userId);
        return this.getAsync('set_group_admin', { groupId, userId, enable });
    }
    async setGroupAnonymous(groupId, enable = true) {
        this._assertInteger('groupId', groupId);
        await this.get('set_group_anonymous', { groupId, enable });
    }
    async setGroupAnonymousAsync(groupId, enable = true) {
        this._assertInteger('groupId', groupId);
        return this.getAsync('set_group_anonymous', { groupId, enable });
    }
    async setGroupCard(groupId, userId, card = '') {
        this._assertInteger('groupId', groupId);
        this._assertInteger('userId', userId);
        await this.get('set_group_card', { groupId, userId, card });
    }
    async setGroupCardAsync(groupId, userId, card = '') {
        this._assertInteger('groupId', groupId);
        this._assertInteger('userId', userId);
        return this.getAsync('set_group_card', { groupId, userId, card });
    }
    async setGroupSpecialTitle(groupId, userId, specialTitle = '', duration = -1) {
        this._assertInteger('groupId', groupId);
        this._assertInteger('userId', userId);
        await this.get('set_group_special_title', { groupId, userId, specialTitle, duration });
    }
    async setGroupSpecialTitleAsync(groupId, userId, specialTitle = '', duration = -1) {
        this._assertInteger('groupId', groupId);
        this._assertInteger('userId', userId);
        return this.getAsync('set_group_special_title', { groupId, userId, specialTitle, duration });
    }
    async setGroupLeave(groupId, isDismiss) {
        this._assertInteger('groupId', groupId);
        await this.get('set_group_leave', { groupId, isDismiss });
    }
    async setGroupLeaveAsync(groupId, isDismiss) {
        this._assertInteger('groupId', groupId);
        return this.getAsync('set_group_leave', { groupId, isDismiss });
    }
    async setDiscussLeave(discussId) {
        this._assertInteger('discussId', discussId);
        await this.get('set_discuss_leave', { discussId });
    }
    async setDiscussLeaveAsync(discussId) {
        this._assertInteger('discussId', discussId);
        return this.getAsync('set_discuss_leave', { discussId });
    }
    async setFriendAddRequest(flag, info = true) {
        if (!flag)
            throw new Error('missing argument: flag');
        if (typeof info === 'string') {
            await this.get('set_friend_add_request', { flag, approve: true, remark: info });
        }
        else {
            await this.get('set_friend_add_request', { flag, approve: info });
        }
    }
    async setFriendAddRequestAsync(flag, info = true) {
        if (!flag)
            throw new Error('missing argument: flag');
        if (typeof info === 'string') {
            return this.getAsync('set_friend_add_request', { flag, approve: true, remark: info });
        }
        else {
            return this.getAsync('set_friend_add_request', { flag, approve: info });
        }
    }
    async setGroupAddRequest(flag, subType, info = true) {
        if (!flag)
            throw new Error('missing argument: flag');
        this._assertElement('subType', subType, ['add', 'invite']);
        if (typeof info === 'string') {
            await this.get('set_group_add_request', { flag, subType, approve: false, reason: info });
        }
        else {
            await this.get('set_group_add_request', { flag, subType, approve: info });
        }
    }
    async setGroupAddRequestAsync(flag, subType, info = true) {
        if (!flag)
            throw new Error('missing argument: flag');
        this._assertElement('subType', subType, ['add', 'invite']);
        if (typeof info === 'string') {
            return this.getAsync('set_group_add_request', { flag, subType, approve: false, reason: info });
        }
        else {
            return this.getAsync('set_group_add_request', { flag, subType, approve: info });
        }
    }
    async getLoginInfo() {
        return this.get('get_login_info');
    }
    async getVipInfo() {
        this._assertVersion('sender.getVipInfo()', 4, 3, 1);
        return this.get('_get_vip_info');
    }
    async getStrangerInfo(userId, noCache) {
        this._assertInteger('userId', userId);
        return this.get('get_stranger_info', { userId, noCache });
    }
    async getFriendList() {
        this._assertVersion('sender.getFriendList()', 4, 12);
        return this.get('get_friend_list');
    }
    async getGroupInfo(groupId, noCache) {
        this._assertInteger('groupId', groupId);
        this._assertVersion('sender.getGroupInfo()', 4, 0, 1);
        return this.app.server.versionLessThan(4, 12)
            ? this.get('_get_group_info', { groupId, noCache })
            : this.get('get_group_info', { groupId, noCache });
    }
    async getGroupList() {
        return this.get('get_group_list');
    }
    async getGroupMemberInfo(groupId, userId, noCache) {
        this._assertInteger('groupId', groupId);
        this._assertInteger('userId', userId);
        return this.get('get_group_member_info', { groupId, userId, noCache });
    }
    async getGroupMemberList(groupId) {
        this._assertInteger('groupId', groupId);
        return this.get('get_group_member_list', { groupId });
    }
    async getGroupNotice(groupId) {
        this._assertInteger('groupId', groupId);
        this._assertVersion('sender.getGroupNotice()', 4, 9);
        return this.get('_get_group_notice', { groupId });
    }
    async sendGroupNotice(groupId, title, content) {
        this._assertInteger('groupId', groupId);
        if (!title)
            throw new Error('missing argument: title');
        if (!content)
            throw new Error('missing argument: content');
        this._assertVersion('sender.sendGroupNotice()', 4, 9);
        await this.get('_send_group_notice', { groupId, title, content });
    }
    async sendGroupNoticeAsync(groupId, title, content) {
        this._assertInteger('groupId', groupId);
        if (!title)
            throw new Error('missing argument: title');
        if (!content)
            throw new Error('missing argument: content');
        this._assertVersion('sender.sendGroupNotice()', 4, 9);
        return this.getAsync('_send_group_notice', { groupId, title, content });
    }
    async getCookies(domain) {
        const { cookies } = await this.get('get_cookies', { domain });
        return cookies;
    }
    async getCsrfToken() {
        const { token } = await this.get('get_csrf_token');
        return token;
    }
    getCredentials(domain) {
        return this.get('get_credentials', { domain });
    }
    async getRecord(file, outFormat, fullPath) {
        if (!file)
            throw new Error('missing argument: file');
        this._assertElement('outFormat', outFormat, ['mp3', 'amr', 'wma', 'm4a', 'spx', 'ogg', 'wav', 'flac']);
        this._assertVersion('sender.getRecord()', 3, 3);
        const response = await this.get('get_record', { file, outFormat, fullPath });
        return response.file;
    }
    async getImage(file) {
        if (!file)
            throw new Error('missing argument: file');
        this._assertVersion('sender.getImage()', 4, 8);
        const response = await this.get('get_image', { file });
        return response.file;
    }
    async canSendRecord() {
        this._assertVersion('sender.canSendRecord()', 4, 8);
        const { yes } = await this.get('can_send_record');
        return yes;
    }
    async canSendImage() {
        this._assertVersion('sender.canSendImage()', 4, 8);
        const { yes } = await this.get('can_send_image');
        return yes;
    }
    getStatus() {
        return this.get('get_status');
    }
    async getVersionInfo() {
        const data = await this.get('get_version_info');
        const match = /^(\d+)(?:\.(\d+)(?:\.(\d+)?))?/.exec(data.pluginVersion);
        if (match) {
            const [, major, minor, patch] = match;
            data.pluginMajorVersion = +major;
            data.pluginMinorVersion = +minor || 0;
            data.pluginPatchVersion = +patch || 0;
        }
        return data;
    }
    async setRestart(cleanLog = false, cleanCache = false, cleanEvent = false) {
        this._assertVersion('sender.setRestart()', 3, 0, 2);
        await this.get('_set_restart', { cleanLog, cleanCache, cleanEvent });
    }
    async setRestartPlugin(delay) {
        this._assertVersion('sender.setRestartPlugin()', 3, 2);
        await this.get('set_restart_plugin', { delay });
    }
    async cleanDataDir(dataDir) {
        this._assertElement('dataDir', dataDir, ['bface', 'image', 'record', 'show']);
        this._assertVersion('sender.cleanDataDir()', 3, 3, 4);
        await this.get('clean_data_dir', { dataDir });
    }
    async cleanDataDirAsync(dataDir) {
        this._assertElement('dataDir', dataDir, ['bface', 'image', 'record', 'show']);
        this._assertVersion('sender.cleanDataDirAsync()', 3, 3, 4);
        return this.getAsync('clean_data_dir', { dataDir });
    }
    async cleanPluginLog() {
        this._assertVersion('sender.cleanPluginLog()', 4, 1);
        await this.get('clean_plugin_log');
    }
    async cleanPluginLogAsync() {
        this._assertVersion('sender.cleanPluginLogAsync()', 4, 1);
        await this.get('clean_plugin_log_async');
    }
}
exports.Sender = Sender;
