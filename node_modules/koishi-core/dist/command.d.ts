import { Context, NextFunction } from './context';
import { UserData, UserField, GroupField } from './database';
import { Meta } from './meta';
import { CommandOption, CommandArgument, OptionConfig, ParsedLine } from './parser';
export interface ParsedCommandLine extends Partial<ParsedLine> {
    meta: Meta<'message'>;
    command?: Command;
    next?: NextFunction;
}
export declare type UserType<T> = T | ((user: UserData) => T);
export declare type CommandUsage = string | ((this: Command, meta: Meta) => string | Promise<string>);
export interface CommandConfig {
    /** disallow unknown options */
    checkUnknown?: boolean;
    /** check required options */
    checkRequired?: boolean;
    /** check argument count */
    checkArgCount?: boolean;
    /** usage identifier */
    usageName?: string;
    /** description */
    description?: string;
    /** min authority */
    authority?: number;
    disable?: UserType<boolean>;
    maxUsage?: UserType<number>;
    minInterval?: UserType<number>;
    showWarning?: boolean | number;
    noHelpOption?: boolean;
}
export interface ShortcutConfig {
    name?: string;
    command?: Command;
    authority?: number;
    hidden?: boolean;
    prefix?: boolean;
    fuzzy?: boolean;
    args?: string[];
    oneArg?: boolean;
    options?: Record<string, any>;
}
export declare enum CommandHint {
    USAGE_EXHAUSTED = 1,
    TOO_FREQUENT = 2,
    LOW_AUTHORITY = 4,
    INSUFFICIENT_ARGUMENTS = 8,
    REDUNANT_ARGUMENTS = 16,
    UNKNOWN_OPTIONS = 32,
    REQUIRED_OPTIONS = 64
}
export declare class Command {
    name: string;
    declaration: string;
    context: Context;
    config: CommandConfig;
    children: Command[];
    parent: Command;
    _aliases: string[];
    _options: CommandOption[];
    _usage?: CommandUsage;
    _examples: string[];
    _shortcuts: Record<string, ShortcutConfig>;
    _userFields: Set<"id" | "flag" | "authority" | "usage">;
    _groupFields: Set<"id" | "flag" | "assignee">;
    _argsDef: CommandArgument[];
    _optsDef: Record<string, CommandOption>;
    _action?: (this: Command, config: ParsedCommandLine, ...args: string[]) => any;
    static attachUserFields(userFields: Set<UserField>, { command, options }: ParsedCommandLine): void;
    static attachGroupFields(groupFields: Set<GroupField>, { command }: ParsedCommandLine): void;
    constructor(name: string, declaration: string, context: Context, config?: CommandConfig);
    get app(): import("./app").App;
    get usageName(): string;
    private _registerAlias;
    userFields(fields: Iterable<UserField>): this;
    groupFields(fields: Iterable<GroupField>): this;
    alias(...names: string[]): this;
    subcommand(rawName: string, config?: CommandConfig): Command;
    subcommand(rawName: string, description: string, config?: CommandConfig): Command;
    shortcut(name: string, config?: ShortcutConfig): this;
    usage(text: CommandUsage): this;
    example(example: string): this;
    /**
     * Add a option for this command
     * @param rawName raw option name(s)
     * @param description option description
     * @param config option config
     */
    option(rawName: string, config?: OptionConfig): this;
    option(rawName: string, description: string, config?: OptionConfig): this;
    removeOption(name: string): boolean;
    action(callback: (this: this, options: ParsedCommandLine, ...args: string[]) => any): this;
    getConfig<K extends keyof CommandConfig>(key: K, meta: Meta<'message'>): Exclude<CommandConfig[K], (user: UserData) => any>;
    parse(source: string): ParsedLine;
    execute(argv: ParsedCommandLine, next?: NextFunction): any;
    private _sendHint;
    /** check authority and usage */
    private _checkUser;
    end(): Context;
}
