"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const koishi_utils_1 = require("koishi-utils");
const command_1 = require("./command");
const messages_1 = require("./messages");
const util_1 = require("util");
const leven_1 = __importDefault(require("leven"));
function getTargetId(target) {
    if (typeof target !== 'string' && typeof target !== 'number')
        return;
    let qq = +target;
    if (!qq) {
        const capture = /\[CQ:at,qq=(\d+)\]/.exec(target);
        if (capture)
            qq = +capture[1];
    }
    if (!koishi_utils_1.isInteger(qq))
        return;
    return qq;
}
exports.getTargetId = getTargetId;
const ONE_DAY = 86400000;
function getUsage(name, user, time = Date.now()) {
    const $date = koishi_utils_1.getDateNumber(time);
    if (user.usage.$date !== $date) {
        const oldUsage = user.usage;
        const newUsage = { $date };
        for (const key in oldUsage) {
            if (key === '$date')
                continue;
            const { last } = oldUsage[key];
            if (time.valueOf() - last < ONE_DAY) {
                newUsage[key] = { last };
            }
        }
        user.usage = newUsage;
    }
    return user.usage[name] || (user.usage[name] = {});
}
exports.getUsage = getUsage;
function updateUsage(name, user, options = {}) {
    const now = Date.now();
    const { maxUsage = Infinity, minInterval = 0, timestamp = now } = options;
    const usage = getUsage(name, user, now);
    if (now - usage.last < minInterval) {
        return command_1.CommandHint.TOO_FREQUENT;
    }
    else if (options.minInterval || options.timestamp) {
        usage.last = timestamp;
    }
    if (usage.count >= maxUsage) {
        return command_1.CommandHint.USAGE_EXHAUSTED;
    }
    else if (options.maxUsage) {
        usage.count = (usage.count || 0) + 1;
    }
}
exports.updateUsage = updateUsage;
function showSuggestions(options) {
    const { target, items, meta, next, prefix, suffix, execute, disable, coefficient = 0.4 } = options;
    const suggestions = items.filter((name) => {
        return name.length > 2
            && leven_1.default(name, target) <= name.length * coefficient
            && !(disable === null || disable === void 0 ? void 0 : disable(name));
    });
    if (!suggestions.length)
        return next();
    return next(() => {
        const message = prefix + util_1.format(messages_1.messages.SUGGESTION_TEXT, suggestions.map(name => `“${name}”`).join('或'));
        if (suggestions.length > 1)
            return meta.$send(message);
        const command = typeof options.command === 'function' ? options.command(suggestions[0]) : options.command;
        const userFields = new Set();
        const groupFields = new Set();
        command_1.Command.attachUserFields(userFields, { command, meta });
        command_1.Command.attachGroupFields(groupFields, { command, meta });
        command.context.onceMiddleware(async (meta, next) => {
            var _a, _b;
            if (meta.message.trim())
                return next();
            meta.$user = await ((_a = command.context.database) === null || _a === void 0 ? void 0 : _a.observeUser(meta.userId, Array.from(userFields)));
            if (meta.messageType === 'group') {
                meta.$group = await ((_b = command.context.database) === null || _b === void 0 ? void 0 : _b.observeGroup(meta.groupId, Array.from(groupFields)));
            }
            return execute(suggestions[0], meta, next);
        }, meta);
        return meta.$send(message + suffix);
    });
}
exports.showSuggestions = showSuggestions;
