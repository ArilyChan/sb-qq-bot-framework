"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ms_1 = __importDefault(require("ms"));
const ws_1 = __importDefault(require("ws"));
const http = __importStar(require("http"));
const messages_1 = require("./messages");
const crypto_1 = require("crypto");
const koishi_utils_1 = require("koishi-utils");
const util_1 = require("util");
class Server {
    constructor(app) {
        this.appList = [];
        this.appMap = {};
        this.isListening = false;
        this.bind(app);
    }
    /**
     * representative app
     */
    get app() {
        return this.appList[0];
    }
    debug(format, ...params) {
        var _a;
        (_a = this.app) === null || _a === void 0 ? void 0 : _a.logger('koishi:server').debug(format, ...params);
    }
    prepareMeta(data) {
        const meta = koishi_utils_1.camelCase(data);
        if (!meta.selfId) {
            // below version 3.4
            meta.selfId = this.app.selfId;
        }
        else if (!this.appMap[meta.selfId]) {
            const app = this.appList.find(app => !app.options.selfId);
            if (!app)
                return;
            app.prepare(meta.selfId);
        }
        return meta;
    }
    parseMeta(meta) {
        // prepare prefix
        let ctxType, ctxId;
        if (meta.groupId) {
            ctxType = 'group';
            ctxId = meta.groupId;
        }
        else if (meta.discussId) {
            ctxType = 'discuss';
            ctxId = meta.discussId;
        }
        else if (meta.userId) {
            ctxType = 'user';
            ctxId = meta.userId;
        }
        // polyfill CQHTTP 3.x events and array form of message
        // https://cqhttp.cc/docs/4.12/#/UpgradeGuide
        /* eslint-disable dot-notation */
        if (meta.postType === 'message') {
            if (typeof meta.anonymous === 'string') {
                meta.anonymous = {
                    name: meta.anonymous,
                    flag: meta['anonymousFlag'],
                };
                delete meta['anonymousFlag'];
            }
            if (Array.isArray(meta.message)) {
                meta.message = koishi_utils_1.CQCode.stringifyAll(meta.message);
            }
            // @ts-ignore
        }
        else if (meta.postType === 'event') {
            meta.postType = 'notice';
            meta.noticeType = meta['event'];
            delete meta['event'];
        }
        else if (meta.postType === 'request' && meta.message) {
            meta.comment = meta.message;
            delete meta.message;
        }
        /* eslint-enable dot-notation */
        // prepare events
        const events = [];
        if (meta.postType === 'message' || meta.postType === 'send') {
            events.push(meta.postType);
        }
        else if (meta.postType === 'request') {
            events.push('request/' + meta.requestType);
        }
        else if (meta.postType === 'notice') {
            events.push(meta.noticeType);
        }
        else {
            events.push(meta.metaEventType);
        }
        if (meta.subType)
            events.unshift(events[0] + '/' + meta.subType);
        // generate path
        Object.defineProperty(meta, '$ctxId', { value: ctxId });
        Object.defineProperty(meta, '$ctxType', { value: ctxType });
        const app = this.appMap[meta.selfId];
        // add context properties
        if (meta.postType === 'message') {
            if (meta.messageType === 'group') {
                meta.$delete = async () => {
                    if (meta.$response)
                        return meta.$response({ delete: true });
                    return app.sender.deleteMsgAsync(meta.messageId);
                };
                meta.$ban = async (duration = 30 * 60) => {
                    if (meta.$response)
                        return meta.$response({ ban: true, banDuration: duration });
                    return meta.anonymous
                        ? app.sender.setGroupAnonymousBanAsync(meta.groupId, meta.anonymous.flag, duration)
                        : app.sender.setGroupBanAsync(meta.groupId, meta.userId, duration);
                };
                meta.$kick = async () => {
                    if (meta.$response)
                        return meta.$response({ kick: true });
                    if (meta.anonymous)
                        return;
                    return app.sender.setGroupKickAsync(meta.groupId, meta.userId);
                };
            }
            meta.$send = async (message, autoEscape = false) => {
                if (meta.$response) {
                    app.emitEvent(meta, 'before-send', app.sender._createSendMeta(meta.messageType, ctxType, ctxId, message));
                    return meta.$response({ reply: message, autoEscape, atSender: false });
                }
                return app.sender[`send${koishi_utils_1.capitalize(meta.messageType)}MsgAsync`](ctxId, message, autoEscape);
            };
        }
        else if (meta.postType === 'request') {
            meta.$approve = async (remark = '') => {
                if (meta.$response)
                    return meta.$response({ approve: true, remark });
                return meta.requestType === 'friend'
                    ? app.sender.setFriendAddRequestAsync(meta.flag, remark)
                    : app.sender.setGroupAddRequestAsync(meta.flag, meta.subType, true);
            };
            meta.$reject = async (reason = '') => {
                if (meta.$response)
                    return meta.$response({ approve: false, reason });
                return meta.requestType === 'friend'
                    ? app.sender.setFriendAddRequestAsync(meta.flag, false)
                    : app.sender.setGroupAddRequestAsync(meta.flag, meta.subType, reason);
            };
        }
        return events;
    }
    dispatchMeta(meta) {
        const app = this.appMap[meta.selfId];
        const events = this.parseMeta(meta);
        for (const event of events) {
            app.emitEvent(meta, koishi_utils_1.paramCase(event), meta);
        }
    }
    bind(app) {
        this.appList.push(app);
        if (app.options.selfId) {
            this.appMap[app.options.selfId] = app;
        }
        return this;
    }
    versionLessThan(major, minor = 0, patch = 0) {
        const { pluginMajorVersion, pluginMinorVersion, pluginPatchVersion } = this.version;
        return pluginMajorVersion < major || pluginMajorVersion === major &&
            (pluginMinorVersion < minor || pluginMinorVersion === minor && pluginPatchVersion < patch);
    }
    async listen() {
        if (this.isListening)
            return;
        this.isListening = true;
        try {
            await this._listen();
            if (this.versionLessThan(3)) {
                throw new Error(messages_1.errors.UNSUPPORTED_CQHTTP_VERSION);
            }
            else if (this.versionLessThan(3, 4)) {
                const apps = this.appList.filter(app => app.options.type && !app.selfId);
                if (apps.length > 1)
                    throw new Error(messages_1.errors.MULTIPLE_ANONYMOUS_BOTS);
                const info = await apps[0].sender.getLoginInfo();
                apps[0].prepare(info.userId);
            }
        }
        catch (error) {
            this.close();
            throw error;
        }
    }
    close() {
        this.version = undefined;
        this.isListening = false;
        this._close();
    }
}
exports.Server = Server;
class HttpServer extends Server {
    constructor(app) {
        super(app);
        const { secret } = app.options;
        this.server = http.createServer((req, res) => {
            let body = '';
            req.on('data', chunk => body += chunk);
            req.on('end', () => {
                if (secret) {
                    // no signature
                    const signature = req.headers['x-signature'];
                    if (!signature) {
                        res.statusCode = 401;
                        return res.end();
                    }
                    // invalid signature
                    const sig = crypto_1.createHmac('sha1', secret).update(body).digest('hex');
                    if (signature !== `sha1=${sig}`) {
                        res.statusCode = 403;
                        return res.end();
                    }
                }
                // no matched application
                const data = JSON.parse(body);
                this.debug('receive %o', data);
                const meta = this.prepareMeta(data);
                if (!meta) {
                    res.statusCode = 403;
                    return res.end();
                }
                // handle quick operations
                res.statusCode = 200;
                const app = this.appMap[meta.selfId];
                if (app.options.quickOperationTimeout > 0) {
                    meta.$response = (data) => {
                        clearTimeout(timer);
                        res.write(JSON.stringify(koishi_utils_1.snakeCase(data)));
                        res.end();
                        meta.$response = null;
                    };
                    const timer = setTimeout(() => {
                        res.end();
                        meta.$response = null;
                    }, app.options.quickOperationTimeout);
                }
                else {
                    res.end();
                }
                // dispatch events
                this.dispatchMeta(meta);
            });
        });
    }
    async _listen() {
        this.debug('http server opening');
        const { port } = this.app.options;
        this.server.listen(port);
        try {
            this.version = await this.app.sender.getVersionInfo();
        }
        catch (error) {
            throw new Error('authorization failed');
        }
        this.debug('http server listen to', port);
    }
    _close() {
        this.server.close();
        this.debug('http server closed');
    }
}
exports.HttpServer = HttpServer;
let counter = 0;
class WsClient extends Server {
    constructor() {
        super(...arguments);
        this._retryCount = 0;
        this._listeners = {};
    }
    send(data) {
        data.echo = ++counter;
        return new Promise((resolve, reject) => {
            this._listeners[counter] = resolve;
            this.socket.send(JSON.stringify(data), (error) => {
                if (error)
                    reject(error);
            });
        });
    }
    _listen() {
        const connect = (resolve, reject) => {
            this.debug('websocket client opening');
            const headers = {};
            const { token, server, retryInterval, retryTimes } = this.app.options;
            if (token)
                headers.Authorization = `Bearer ${token}`;
            this.socket = new ws_1.default(server, { headers });
            this.socket.on('error', error => this.debug(error));
            this.socket.once('close', (code) => {
                if (!this.isListening || code === 1005)
                    return;
                const message = `failed to connect to ${server}`;
                if (!retryInterval || this._retryCount >= retryTimes) {
                    return reject(new Error(message));
                }
                this._retryCount++;
                this.debug(`${message}, will retry in ${ms_1.default(retryInterval)}...`);
                setTimeout(() => {
                    if (this.isListening)
                        connect(resolve, reject);
                }, retryInterval);
            });
            this.socket.once('open', () => {
                this._retryCount = 0;
                this.socket.send(JSON.stringify({
                    action: 'get_version_info',
                    echo: -1,
                }), (error) => {
                    if (error)
                        reject(error);
                });
                this.socket.on('message', (data) => {
                    var _a, _b;
                    data = data.toString();
                    this.debug('receive', data);
                    let parsed;
                    try {
                        parsed = JSON.parse(data);
                    }
                    catch (error) {
                        return reject(new Error(data));
                    }
                    if ('post_type' in parsed) {
                        const meta = this.prepareMeta(parsed);
                        if (meta)
                            this.dispatchMeta(meta);
                    }
                    else if (parsed.echo === -1) {
                        this.version = koishi_utils_1.camelCase(parsed.data);
                        this.debug('connect to ws server:', this.app.options.server);
                        resolve();
                        (_b = (_a = this._listeners)[parsed.echo]) === null || _b === void 0 ? void 0 : _b.call(_a, parsed);
                    }
                });
            });
        };
        return new Promise(connect);
    }
    _close() {
        this.socket.close();
        this._retryCount = 0;
        this.debug('websocket client closed');
    }
}
exports.WsClient = WsClient;
exports.serverMap = { http: {}, ws: {} };
function createServer(app) {
    if (typeof app.options.type !== 'string') {
        throw new Error(messages_1.errors.UNSUPPORTED_SERVER_TYPE);
    }
    app.options.type = app.options.type.toLowerCase();
    let key, Server;
    if (app.options.type === 'http') {
        key = 'port';
        Server = HttpServer;
    }
    else if (app.options.type === 'ws') {
        key = 'server';
        Server = WsClient;
    }
    else {
        throw new Error(messages_1.errors.UNSUPPORTED_SERVER_TYPE);
    }
    const servers = exports.serverMap[app.options.type];
    const value = app.options[key];
    if (!value) {
        throw new Error(util_1.format(messages_1.errors.MISSING_CONFIGURATION, key));
    }
    if (value in servers) {
        return servers[value].bind(app);
    }
    return servers[value] = new Server(app);
}
exports.createServer = createServer;
